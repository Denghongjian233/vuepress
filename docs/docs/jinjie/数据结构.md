<!--
 * @Author: dhj 17613071153@163.com
 * @Date: 2023-03-21 15:35:56
 * @LastEditors: dhj 17613071153@163.com
 * @LastEditTime: 2023-03-22 15:47:45
 * @FilePath: \vuepress\docs\docs\jinjie\数据结构.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
### 数据结构

数组 

栈

链表

图

散列表

队列

堆

树

### 数组

数据的集合。一些数据放在一个盒子里、按照顺序排好

shift  unshift 返回数组长度

pop   push 返回数组长度

splice sort concat join

every some filter map foreach reduce

迭代器对象 arr Symbol.iterator next 

let of 遍历

entries values

Array.form

搜索 

find findIndex findLast findLastIndex

includes

### 栈

堆栈 运算受限的线性表。限定仅在表尾（栈顶）进行插入和删除的线性表。另一端是栈低、插入新元素称为进栈 

后进先出



class Stack{
  #items = []

  pop(){
    return this.#items.pop()

  }
  push(data){
    this.#items.push(data)

  }
  peek(){
    // return this.#items[this.#items.length-1]
    return this.#items.at(-1)
  }
  size(){
    return this.#items.length
  }
  clear(){
    this.#items = []
  }
  isEmpty(){
    return this.#items.length === 0
  }
}
5

let stack = new Stack()

function convert(decNumber,base){
  let remStack = new Stack()
  let number = decNumber
  let string = ''
  let baseString = '0123456789ABCDEF'
  while(number>0){
    remStack.push(number%base)
    number = Math.floor(number/base)
    console.log(number,33)
  }
  while(!(remStack.isEmpty())){
    string+=baseString[remStack.pop()]
    console.log(string,4)
  }
  return string
}
console.log(convert(8888,16))

### 队列

队列是一种特殊的线性表、只允许在表的前端front进行删除操作，而在表的后端进行插入操作 先进先出

class Queue {
  #item = {}
  #lowCount = 0
  #count = 0
  dequeue(){
    if(this.isEmpty()){
      return undefined
    }
    let res = this.#item[this.#lowCount]
    delete this.#item[this.#lowCount]
    this.#lowCount ++
    return res
  }
  enqueue(data){
     this.#item[this.#count] = data
     this.#count ++
  }
  size(){
    return this.#count - this.#lowCount
  }
  isEmpty(){
    return this.size() === 0
  }
  front(){
    return this.#item[this.#lowCount]
  }
  clear(){
    this.#item = {}
    this.#count = 0
    this.#lowCount = 0
  }
  toString(){
    let str = ''
    for(let i = this.#lowCount;i<this.#count;i++){
      str+=`${this.#item[i]}`
    }
    return str
  }
}
const queue = new Queue()

队列应用

class Queue {
  #item = {}
  #lowCount = 0
  #count = 0
  dequeue() {
    if (this.isEmpty()) {
      return undefined
    }
    let res = this.#item[this.#lowCount]
    delete this.#item[this.#lowCount]
    this.#lowCount ++
    return res
  }
  enqueue(data) {
    this.#item[this.#count] = data
    this.#count ++
  }
  size() {
    return this.#count - this.#lowCount
  }
  isEmpty() {
    return this.size() === 0
  }
  front() {
    return this.#item[this.#lowCount]
  }
  clear() {
    this.#item = {}
    this.#count = 0
    this.#lowCount = 0
  }
  toString() {
    let str = ''
    for (let i = this.#lowCount; i < this.#count; i++) {
      str += `${this.#item[i]}`
    }
    return str
  }
}
function gamae(arr, num) {
  let queue = new Queue()
  for (let i = 0; i < arr.length; i++) {
    queue.enqueue(arr[i])
  }
  console.log(queue)
  while (queue.size() > 1) {
    for (let j = 0; j < num; j++) {
      queue.enqueue(queue.dequeue())
    }
    console.log(queue.dequeue(), 'chuju')
  }
  return queue.dequeue()
}
const a = [1, 2, 3]
console.log(gamae(a, 2))
