## docker 容器

轻量级的虚拟化技术。对进程进行隔离的运行的环境。

生产环境的容器几乎都是运行在Linux上的，进程、Docker、软件以linux为准。

进程是linux操作系统执行任务的最小单元，一个时间同步服务是一个进程，一个java服务是一个进程、一个nginx服务是一个主进程+若干个工作进程。

系统是一个办公室、进程就是一个一个打工人。

一个进程是能感知到其他进程的存在的。进程的唯一标识是进程ID 1,2,3表示

容器技术首先要解决的就是进程的隔离、即一个进程在运行的时候看不到其他进程。

Namespace 和 Cgroup两大机制实现的。一个被隔离的进程，操作系统也会正常跟配进程ID，比如12345.

但是隔离进程看到的ID 总是1 

我们通过一个简单的Python程序就可以验证一个进程的特点.编写一个简单的HTTP服务程序，针对URL为/，/ps，/ls分别返回自身进程ID.

所有的进程ID和磁盘根目录列表；

再用/ls看一下磁盘，看到的也不是系统的根目录，而是Docker给挂载的一个虚拟的文件系统：

一个容器进程本质上是一个运行在沙盒中的隔离进程，由Linux系统本身负责隔离，Docker只是提供了一系列工具，帮助我们设置好隔离环境后，启动这个进程。

最基本的隔离就是进程之间看不到彼此，这是由linux的Cgroup机制实现的。

进程隔离的结果就是以隔离方式启动的进程看到的自身进程ID总是1，且看不到系统的其他进程

第二种隔离就是隔离系统真实的文件系统。Docker利用Linux的mount机制，给每个隔离进程挂载了一个虚拟的文件系统、使得每一个隔离进程只能访问这个虚拟的文件系统，

无法看到系统真实的文件系统。

比如我们的Python程序要正常运行，需要一个Python3解释器，需要把用到的第三方库如psutil引入进来，这些复杂的工作被简化为一个Dockerfile，再由Docker把这些运行时的依赖打包，就形成了Docker镜像

我们可以把一个Docker镜像看作一个zip包，每启动一个进程，Docker都会自动解压zip包，把它变成一个虚拟的文件系统。

第三种隔离就是网络协议栈的隔离

在Docker中运行docker run redis:latest  后在宿主机上写个程序连接127.0.0.1:6379，是无法连接到Redis的 Linux可以为进程隔离网络，Docker默认启动的Redis进程拥有自己的网络名字空间，与宿主机不同

