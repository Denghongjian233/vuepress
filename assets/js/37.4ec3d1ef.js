(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{310:function(v,_,t){"use strict";t.r(_);var p=t(14),e=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"get和post的区别-put"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post的区别-put"}},[v._v("#")]),v._v(" get和post的区别 put")]),v._v(" "),_("p",[v._v("get请求是一个幂的请求，一般get请求同于对服务器资源不会产生影响的场景、比如说请求一个网页的资源")]),v._v(" "),_("p",[v._v("而post不是一个幂等的请求、一般用于对服务器资源会产生影响的情景、比如注册用户这一类的操作。")]),v._v(" "),_("p",[v._v("缓存：浏览器一般会对get请求缓存、而不会对post请求缓存")]),v._v(" "),_("p",[v._v("发送报文格式：get请求的报文中实体部分为空，post其你去的报文中实体部分一般为向服务器发送的宋局。")]),v._v(" "),_("p",[v._v("安全性：get请求可以将参数放入url中向服务器发送、这样的做法相对于post请求是不太安全的、因为请求的url会被保留在历史记录中")]),v._v(" "),_("p",[v._v("请求长度：浏览器由于对url长度的限制、所以会影响get请求发送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的")]),v._v(" "),_("p",[v._v("参数类型：post的参数传递支持更多的数据类型。")]),v._v(" "),_("p",[v._v("put 请求是向服务端发送数据，从而修改数据的内容。但是不会增加数据的种类，也就是说无论进行多少次put操作，其结果没有不同。可以理解为时更新数据")]),v._v(" "),_("p",[v._v("post请求是向服务器端发送数据、该请求会改变数据的种类资源等，它会创建新的内容。可以理解为时创建数据")]),v._v(" "),_("h3",{attrs:{id:"常见的http请求头和响应头"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求头和响应头"}},[v._v("#")]),v._v(" 常见的http请求头和响应头")]),v._v(" "),_("p",[v._v("http request header常见的请求头")]),v._v(" "),_("p",[v._v("accept:浏览器能够处理的内容类型")]),v._v(" "),_("p",[v._v("accept-charset:浏览器能够显示的字符集")]),v._v(" "),_("p",[v._v("accept-encoding:浏览器能够处理的压缩编码")]),v._v(" "),_("p",[v._v("accept-language:浏览器当前设置的语言")]),v._v(" "),_("p",[v._v("connection:浏览器与服务器之间连接的类型")]),v._v(" "),_("p",[v._v("cookie:当前页面设置的任何cookie")]),v._v(" "),_("p",[v._v("host:发出请求页面所在的域")]),v._v(" "),_("p",[v._v("referer:发出请求的页面的url")]),v._v(" "),_("p",[v._v("user-agent:浏览器的用户代理字符串")]),v._v(" "),_("p",[v._v("http responses header常见的响应头")]),v._v(" "),_("p",[v._v("data:表示消息发送的时间，时间的描述格式由rfc822定义")]),v._v(" "),_("p",[v._v("server:服务器名称")]),v._v(" "),_("p",[v._v("connection:浏览器与服务器之间连接的类型")]),v._v(" "),_("p",[v._v("cache-control:控制HTTP缓存")]),v._v(" "),_("p",[v._v("content-type:表示后面的文档属于什么MIME类型")]),v._v(" "),_("p",[v._v("常见的content-type属性值有以下四种")]),v._v(" "),_("ol",[_("li",[v._v("application/x-www-form-urlencoded:浏览器的原生form表单")])]),v._v(" "),_("p",[v._v("如果不设置enctype属性,那么最终就会以application/x-www-form-urlencoded方式提交数据")]),v._v(" "),_("p",[v._v("该种方式提交的数据放在body里面，数据按照key=1&key=value2的方式进行编码，key和val都进行了url转码。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[v._v("mulipart/form-data:该种方式也是一个常见的post提交方式，通常表单上传文件时使用该种方式。")])]),v._v(" "),_("li",[_("p",[v._v("application/json:服务器消息主体是序列化后的JSON字符串")])]),v._v(" "),_("li",[_("p",[v._v("text/xml:该种方式主要用来提供XML格式的数据")])])]),v._v(" "),_("h3",{attrs:{id:"常见的http请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求方法"}},[v._v("#")]),v._v(" 常见的HTTP请求方法")]),v._v(" "),_("p",[v._v("get：向服务器获取数据")]),v._v(" "),_("p",[v._v("post：将实体提交到指定的资源，通常会造成服务器资源的修改")]),v._v(" "),_("p",[v._v("put:上传文件、更新数据。")]),v._v(" "),_("p",[v._v("delete：删除服务器上的数据")]),v._v(" "),_("p",[v._v("head：获取报文首部，与get相比，不返回报文主体部分")]),v._v(" "),_("p",[v._v("options：询问支持的请求方法，用来跨域请求；")]),v._v(" "),_("p",[v._v("用于请求获得由Request-url标识的资源在请求、响应的通信过程中可以使用的功能选项")]),v._v(" "),_("p",[v._v("客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。不能缓存")]),v._v(" "),_("p",[v._v("主要用途：获取服务器支持的所有http请求方法")]),v._v(" "),_("p",[v._v("用来检查访问权限。在进行cors跨域资源共享时，对于复杂的请求，")]),v._v(" "),_("p",[v._v("connect：要求与黛米服务器通信时建立隧道，使用隧道进行TCP通信")]),v._v(" "),_("p",[v._v("trace：回显服务器收到的请求，主要用于测试和诊断。")]),v._v(" "),_("h3",{attrs:{id:"http1-0-1-1-2-0区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-1-1-2-0区别"}},[v._v("#")]),v._v(" http1.0 1.1 2.0区别")]),v._v(" "),_("p",[_("code",[v._v("连接方面")]),v._v(" 1.0 非持久连接，1.1默认是持久连接。1.1通过使用持久连接来使多个http请求复用同一个TCP连接，以此来避免使用非持久连接时每次需要建立连接的延毕。")]),v._v(" "),_("p",[_("code",[v._v("资源请求方面")]),v._v(" 1.0有浪费带宽的现象、客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1在请求有加入了range头域")]),v._v(" "),_("p",[v._v("它允许只请求资源的某个部分，既返回码是206，这样就方便了开发者自由的选择以便充分利用带宽和连接。")]),v._v(" "),_("p",[_("code",[v._v("缓存方面")]),v._v(" 1 中使用的header里的modified-since、expires来作为缓存判断的标准，http1.1则引入了更多的缓存控制策略，例如Etag，if inmodified-since，ifmatch，if none match")]),v._v(" "),_("p",[v._v("可供选择的缓存头来控制缓存策略")]),v._v(" "),_("p",[v._v("1.1 新增了host字段，用来指定服务器的域名。1中认为每台服务器都绑定一个为一个IP地址，因此请求消息中的url没有传递主机名")]),v._v(" "),_("p",[v._v("但随着虚拟机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个ip地址，这才有了host字段。这样就可以将请求发送到同一台服务器上的不同网站。")]),v._v(" "),_("p",[v._v("1.1 新增了很多请求方法 put head options")]),v._v(" "),_("p",[v._v("http2是一个二进制协议，1.1版本中，报文的头信息必须是文本 ascll编码，数据体可以是文本，也可以是二进制。")]),v._v(" "),_("p",[v._v("2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为帧、可以分为头信息帧和数据帧。帧的概念是它实现多路复用的基础。")]),v._v(" "),_("p",[v._v("多路复用 2实现了多路复用，2仍然复用TCP连接，但是在一个连接里，客户端和服务器都可以同事发送多个请求或回应。而且不同按照顺序一一发送，这样就避免了队头阻塞的问题")]),v._v(" "),_("p",[v._v("2使用了数据流的概念，因为http2的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能术语不同的请求。")]),v._v(" "),_("p",[v._v("因此，必须要对数据包做标记，指出它属于哪个请求。 2将每个请求或回应的所有数据包。称为一个数据流。每个数据流都有一个独一无二的编号。")]),v._v(" "),_("p",[v._v("数据发送时，都必须标记数据流ID.用来区分它属于哪个数据流。")]),v._v(" "),_("p",[v._v("2实现了头信息压缩，由于1。1协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的。")]),v._v(" "),_("p",[v._v("比如cookie和user agent，一摸一样的内容，每次请求都必须附带，")]),v._v(" "),_("p",[v._v("这会浪费很多带宽，也影响速度。2对这一点做了优化，引入了头信息压缩机制。一方面有信息使用gzip或compress压缩后再发送")]),v._v(" "),_("p",[v._v("另一方面，客户端和服务器同事维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了。只发送索引号，这样就能提高速度了")]),v._v(" "),_("p",[v._v("服务器推送：2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，")]),v._v(" "),_("p",[v._v("这样就可以相对减少一些延迟时间，这里需要注意的是2下服务器主动推送的是静态资源，和websocket以及使用sse等方式向客户端发送即时数据的推送是不同的。")]),v._v(" "),_("h3",{attrs:{id:"http和https协议的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http和https协议的区别"}},[v._v("#")]),v._v(" http和https协议的区别")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("s需要ca证书。费用较高")])]),v._v(" "),_("li",[_("p",[v._v("http信息是明文传输的，s则是具有安全性的ssl加密传输协议")])]),v._v(" "),_("li",[_("p",[v._v("使用不同的连接方式，端口也不同 80 443")])]),v._v(" "),_("li",[_("p",[v._v("http 链接是无状态的，s协议是有ssl和http构建的可加密传输，身份认证的网络协议，比http安全。")])])]),v._v(" "),_("h3",{attrs:{id:"地址栏输入goole-com敲回车"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#地址栏输入goole-com敲回车"}},[v._v("#")]),v._v(" 地址栏输入goole.com敲回车")]),v._v(" "),_("ol",[_("li",[v._v("解析url 对url解析。分析所需要使用的传输协议和请求资源的路径。如果输入的url中的协议或者主机名不合法。")])]),v._v(" "),_("p",[v._v("有问题 将会把地址栏中输入的内容传递给搜索引擎，如果没有问题，浏览器会检查url中是否出现了非法字符，如果有，对非法字符转义。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[v._v("缓存判断：浏览器判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效。那么直接使用。否则向服务器发送请求")])]),v._v(" "),_("li",[_("p",[v._v("DNS解析：需要获取的是输入url中域名的ip地址，首先会判断本地是否有该域名的IP地址的缓存、如果有就使用，没有就向本地的DNS服务器发送请求")])])]),v._v(" "),_("p",[v._v("本地DNS服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发送请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，")]),v._v(" "),_("p",[v._v("然后获得负责权威域名服务器的地址后、再向权威域名服务器发起请求，最终获得域名的IP地址后，")]),v._v(" "),_("p",[v._v("本地DNS服务器再将这个IP地址返回给请求的用户。用户向本地DNS服务器发起请求属于递归请求，本地DNS服务器向各级域名服务器发起请求属于迭代请求。")]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("获取mac地址：浏览器得到ip地址后，数据传输还需要知道目的主机的mac地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号 然后下发给网络层")])]),v._v(" "),_("p",[v._v("网络层会将本机地址作为原地址、获取的ip地址作为目的地址。")]),v._v(" "),_("p",[v._v("然后下发给数据链层，数据链层的发送需要加入通信双方的mac地址，本机的mav地址作为源mav地址、目的mac地址需要分情况处理。")]),v._v(" "),_("p",[v._v("通过将IP地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用APR协议获取目的主机的MAC地址。")]),v._v(" "),_("p",[v._v("如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议来获取网关的MAC地址，此时目的主机的mac地址应该为网关的地址")]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("TCP三次握手，客户端向服务端发送一个SYN连接请求报文段和一个随机序号，")])]),v._v(" "),_("p",[v._v("服务端接收到请求后向客户端发送一个syn ack报文短，确认连接请求，并且也向客户端发送一个随机序号。")]),v._v(" "),_("p",[v._v("客户端接收到服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK确认报文段，")]),v._v(" "),_("p",[v._v("服务器接收到确认后。也进入连接建立状态，此时双方的连接建立了、")]),v._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[v._v("https握手 如果使用的是HTTPS协议 通信之前还存在TLS的一个四次握手的过程。")])]),v._v(" "),_("p",[v._v("客户端向服务端发送使用协议的版本号、一个随机数和可以使用的加密方法。服务端收到")]),v._v(" "),_("p",[v._v("服务端 确认加密方法， 给客户端发一个随机数，和自己的数字证书。客户端收到")]),v._v(" "),_("p",[v._v("客户端检查数字证书是否有效、有效-》生成随机数，并且视同公证书中的公钥对随机数加密 发送给服务端 还会提供一个前面所有内容的hash值供服务器端检验 服务端接收")]),v._v(" "),_("p",[v._v("服务端使用自己的秘钥对数据解密 同时向客户端发送一个前面所有内容的hash值供客户端检验。")]),v._v(" "),_("p",[v._v("这个双方都有三分随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，")]),v._v(" "),_("p",[v._v("以后双方通信前，就使用这个秘钥对数据进行加密后再传输。")]),v._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[_("p",[v._v("返回数据 当页面请求发送到服务器端后，服务器端会返回一个html文件作为响应，浏览器接收到响应后。开始对html文件进行解析，开始页面的渲染。")])]),v._v(" "),_("li",[_("p",[v._v("页面渲染：浏览器首先会根据html文件构建dom树、根据解析到的css文件构建cssom树。如果遇到script标签 判断是否含有defer或者async属性。不然script的加载会造成页面阻塞。")])])]),v._v(" "),_("p",[v._v("当dom树和cssdom树建立好之后，根据他们来构建渲染树。渲染树构建好，就进行布局。乬完成 使用浏览器的ui接口对页面进行绘制，")]),v._v(" "),_("ol",{attrs:{start:"9"}},[_("li",[v._v("tcp四次挥手。")])]),v._v(" "),_("p",[v._v("客户端认为数据发送完成，需要向服务端发送连接释放请求。")]),v._v(" "),_("p",[v._v("服务端收到连接释放请求，告诉应用层，要释放TCP链接。然后会发送ACK包，并进入close_wait状态，此时表示客户端到服务端的连接已经释放，不再接受客户端发的数据了")]),v._v(" "),_("p",[v._v("但是TCP连接时双向的，服务端仍然可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入last_ack状态")]),v._v(" "),_("p",[v._v("客户端收到之后 向服务端发送确认应答 客户端进入time_wait状态")]),v._v(" "),_("p",[v._v("该状态持续2msl 最大段生存期 指报文段在网络中的生存的时间，超时会被抛弃 时间")]),v._v(" "),_("p",[v._v("若改时间段内服务端没有重发请求的话 就进入closed状态。")]),v._v(" "),_("p",[v._v("服务端收到确认应答 进入closed状态。")])])}),[],!1,null,null,null);_.default=e.exports}}]);