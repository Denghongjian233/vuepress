(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{321:function(n,t,e){"use strict";e.r(t);var s=e(14),i=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[n._v("#")]),n._v(" 数据结构")]),n._v(" "),t("p",[n._v("数组")]),n._v(" "),t("p",[n._v("栈")]),n._v(" "),t("p",[n._v("链表")]),n._v(" "),t("p",[n._v("图")]),n._v(" "),t("p",[n._v("散列表")]),n._v(" "),t("p",[n._v("队列")]),n._v(" "),t("p",[n._v("堆")]),n._v(" "),t("p",[n._v("树")]),n._v(" "),t("h3",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[n._v("#")]),n._v(" 数组")]),n._v(" "),t("p",[n._v("数据的集合。一些数据放在一个盒子里、按照顺序排好")]),n._v(" "),t("p",[n._v("shift  unshift 返回数组长度")]),n._v(" "),t("p",[n._v("pop   push 返回数组长度")]),n._v(" "),t("p",[n._v("splice sort concat join")]),n._v(" "),t("p",[n._v("every some filter map foreach reduce")]),n._v(" "),t("p",[n._v("迭代器对象 arr Symbol.iterator next")]),n._v(" "),t("p",[n._v("let of 遍历")]),n._v(" "),t("p",[n._v("entries values")]),n._v(" "),t("p",[n._v("Array.form")]),n._v(" "),t("p",[n._v("搜索")]),n._v(" "),t("p",[n._v("find findIndex findLast findLastIndex")]),n._v(" "),t("p",[n._v("includes")]),n._v(" "),t("h3",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[n._v("#")]),n._v(" 栈")]),n._v(" "),t("p",[n._v("堆栈 运算受限的线性表。限定仅在表尾（栈顶）进行插入和删除的线性表。另一端是栈低、插入新元素称为进栈")]),n._v(" "),t("p",[n._v("后进先出")]),n._v(" "),t("p",[n._v("class Stack{\n#items = []")]),n._v(" "),t("p",[n._v("pop(){\nreturn this.#items.pop()")]),n._v(" "),t("p",[n._v("}\npush(data){\nthis.#items.push(data)")]),n._v(" "),t("p",[n._v("}\npeek(){\n// return this.#items[this.#items.length-1]\nreturn this.#items.at(-1)\n}\nsize(){\nreturn this.#items.length\n}\nclear(){\nthis.#items = []\n}\nisEmpty(){\nreturn this.#items.length === 0\n}\n}\n5")]),n._v(" "),t("p",[n._v("let stack = new Stack()")]),n._v(" "),t("p",[n._v("function convert(decNumber,base){\nlet remStack = new Stack()\nlet number = decNumber\nlet string = ''\nlet baseString = '0123456789ABCDEF'\nwhile(number>0){\nremStack.push(number%base)\nnumber = Math.floor(number/base)\nconsole.log(number,33)\n}\nwhile(!(remStack.isEmpty())){\nstring+=baseString[remStack.pop()]\nconsole.log(string,4)\n}\nreturn string\n}\nconsole.log(convert(8888,16))")]),n._v(" "),t("h3",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[n._v("#")]),n._v(" 队列")]),n._v(" "),t("p",[n._v("队列是一种特殊的线性表、只允许在表的前端front进行删除操作，而在表的后端进行插入操作 先进先出")]),n._v(" "),t("p",[n._v("class Queue {\n#item = {}\n#lowCount = 0\n#count = 0\ndequeue(){\nif(this.isEmpty()){\nreturn undefined\n}\nlet res = this.#item[this.#lowCount]\ndelete this.#item[this.#lowCount]\nthis.#lowCount ++\nreturn res\n}\nenqueue(data){\nthis.#item[this.#count] = data\nthis.#count ++\n}\nsize(){\nreturn this.#count - this.#lowCount\n}\nisEmpty(){\nreturn this.size() === 0\n}\nfront(){\nreturn this.#item[this.#lowCount]\n}\nclear(){\nthis.#item = {}\nthis.#count = 0\nthis.#lowCount = 0\n}\ntoString(){\nlet str = ''\nfor(let i = this.#lowCount;i<this.#count;i++){\nstr+="),t("code",[n._v("${this.#item[i]}")]),n._v("\n}\nreturn str\n}\n}\nconst queue = new Queue()")]),n._v(" "),t("p",[n._v("队列应用")]),n._v(" "),t("p",[n._v("class Queue {\n#item = {}\n#lowCount = 0\n#count = 0\ndequeue() {\nif (this.isEmpty()) {\nreturn undefined\n}\nlet res = this.#item[this.#lowCount]\ndelete this.#item[this.#lowCount]\nthis.#lowCount ++\nreturn res\n}\nenqueue(data) {\nthis.#item[this.#count] = data\nthis.#count ++\n}\nsize() {\nreturn this.#count - this.#lowCount\n}\nisEmpty() {\nreturn this.size() === 0\n}\nfront() {\nreturn this.#item[this.#lowCount]\n}\nclear() {\nthis.#item = {}\nthis.#count = 0\nthis.#lowCount = 0\n}\ntoString() {\nlet str = ''\nfor (let i = this.#lowCount; i < this.#count; i++) {\nstr += "),t("code",[n._v("${this.#item[i]}")]),n._v("\n}\nreturn str\n}\n}\nfunction gamae(arr, num) {\nlet queue = new Queue()\nfor (let i = 0; i < arr.length; i++) {\nqueue.enqueue(arr[i])\n}\nconsole.log(queue)\nwhile (queue.size() > 1) {\nfor (let j = 0; j < num; j++) {\nqueue.enqueue(queue.dequeue())\n}\nconsole.log(queue.dequeue(), 'chuju')\n}\nreturn queue.dequeue()\n}\nconst a = [1, 2, 3]\nconsole.log(gamae(a, 2))")])])}),[],!1,null,null,null);t.default=i.exports}}]);