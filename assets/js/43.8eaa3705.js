(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{316:function(v,_,e){"use strict";e.r(_);var r=e(14),o=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"docker-容器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器"}},[v._v("#")]),v._v(" docker 容器")]),v._v(" "),_("p",[v._v("轻量级的虚拟化技术。对进程进行隔离的运行的环境。")]),v._v(" "),_("p",[v._v("生产环境的容器几乎都是运行在Linux上的，进程、Docker、软件以linux为准。")]),v._v(" "),_("p",[v._v("进程是linux操作系统执行任务的最小单元，一个时间同步服务是一个进程，一个java服务是一个进程、一个nginx服务是一个主进程+若干个工作进程。")]),v._v(" "),_("p",[v._v("系统是一个办公室、进程就是一个一个打工人。")]),v._v(" "),_("p",[v._v("一个进程是能感知到其他进程的存在的。进程的唯一标识是进程ID 1,2,3表示")]),v._v(" "),_("p",[v._v("容器技术首先要解决的就是进程的隔离、即一个进程在运行的时候看不到其他进程。")]),v._v(" "),_("p",[v._v("Namespace 和 Cgroup两大机制实现的。一个被隔离的进程，操作系统也会正常跟配进程ID，比如12345.")]),v._v(" "),_("p",[v._v("但是隔离进程看到的ID 总是1")]),v._v(" "),_("p",[v._v("我们通过一个简单的Python程序就可以验证一个进程的特点.编写一个简单的HTTP服务程序，针对URL为/，/ps，/ls分别返回自身进程ID.")]),v._v(" "),_("p",[v._v("所有的进程ID和磁盘根目录列表；")]),v._v(" "),_("p",[v._v("再用/ls看一下磁盘，看到的也不是系统的根目录，而是Docker给挂载的一个虚拟的文件系统：")]),v._v(" "),_("p",[v._v("一个容器进程本质上是一个运行在沙盒中的隔离进程，由Linux系统本身负责隔离，Docker只是提供了一系列工具，帮助我们设置好隔离环境后，启动这个进程。")]),v._v(" "),_("p",[v._v("最基本的隔离就是进程之间看不到彼此，这是由linux的Cgroup机制实现的。")]),v._v(" "),_("p",[v._v("进程隔离的结果就是以隔离方式启动的进程看到的自身进程ID总是1，且看不到系统的其他进程")]),v._v(" "),_("p",[v._v("第二种隔离就是隔离系统真实的文件系统。Docker利用Linux的mount机制，给每个隔离进程挂载了一个虚拟的文件系统、使得每一个隔离进程只能访问这个虚拟的文件系统，")]),v._v(" "),_("p",[v._v("无法看到系统真实的文件系统。")]),v._v(" "),_("p",[v._v("比如我们的Python程序要正常运行，需要一个Python3解释器，需要把用到的第三方库如psutil引入进来，这些复杂的工作被简化为一个Dockerfile，再由Docker把这些运行时的依赖打包，就形成了Docker镜像")]),v._v(" "),_("p",[v._v("我们可以把一个Docker镜像看作一个zip包，每启动一个进程，Docker都会自动解压zip包，把它变成一个虚拟的文件系统。")]),v._v(" "),_("p",[v._v("第三种隔离就是网络协议栈的隔离")]),v._v(" "),_("p",[v._v("在Docker中运行docker run redis:latest  后在宿主机上写个程序连接127.0.0.1:6379，是无法连接到Redis的 Linux可以为进程隔离网络，Docker默认启动的Redis进程拥有自己的网络名字空间，与宿主机不同")])])}),[],!1,null,null,null);_.default=o.exports}}]);