(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{295:function(t,o,_){"use strict";_.r(o);var p=_(14),v=Object(p.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("JS 的数据类型分为两大类 普通数据类型和引用数据类型")]),t._v(" "),o("p",[t._v("可以用数据结构中的堆和栈简单理解")]),t._v(" "),o("p",[t._v("普通数据类型 数字 字符串 undefined null 布尔")]),t._v(" "),o("p",[t._v("引用数据类型 函数 数组 对象 字符")]),t._v(" "),o("p",[t._v("如何区分可以用type of 它可以返回一个表示数据类型的字符串 返回结果包括 number boolean string pbject undefined funtion")]),t._v(" "),o("p",[t._v("因为对象的原型链都指向了Object")]),t._v(" "),o("p",[t._v("不能区分数组 对象 null")]),t._v(" "),o("p",[t._v("A intanceof B a是b的实例就返回true 否则返回false")]),t._v(" "),o("p",[t._v("a.__proto = b.prototype")]),t._v(" "),o("p",[t._v("constructor")]),t._v(" "),o("p",[t._v("当一个函数被定义时、JS会为F添加prototype原型 然后再在protype上添加一个constructor属性并让其指向自己")]),t._v(" "),o("p",[t._v("F被当成构造函数时、f是F的实例对象 f.constructor === F")]),t._v(" "),o("h3",{attrs:{id:"深究js原型链"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#深究js原型链"}},[t._v("#")]),t._v(" 深究JS原型链")]),t._v(" "),o("p",[t._v("继承 JS以前是没有类的概念 是一门原型继承的语言、")]),t._v(" "),o("p",[t._v("后来ES6中加入了类的概念、加入了extends关键字、这可以看成es5继承方式的语法糖，更加的合法化、规范化")]),t._v(" "),o("p",[t._v("什么原型呢 就是模型 把对象看成车 原型就是车厂 construstor 车子的额外功能 启动 刹车 这个就是原型 prototype")]),t._v(" "),o("p",[t._v("总结一下就是 constructor 决定 样子 名称 固定的属性")]),t._v(" "),o("p",[t._v("原型 prototype 决定功能 原型对象")]),t._v(" "),o("p",[t._v("JS有一句话 万物皆对象、每个对象都有原型。")]),t._v(" "),o("p",[t._v("继承原理、prototype,proto, constructor")])])}),[],!1,null,null,null);o.default=v.exports}}]);