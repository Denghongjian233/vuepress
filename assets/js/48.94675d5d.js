(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{320:function(t,n,e){"use strict";e.r(n);var s=e(14),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"架构师的责任"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#架构师的责任"}},[t._v("#")]),t._v(" 架构师的责任")]),t._v(" "),n("p",[t._v("架构设计和核心开发、工程方案调研和选型")]),t._v(" "),n("h3",{attrs:{id:"npm-yarn"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm-yarn"}},[t._v("#")]),t._v(" npm yarn")]),t._v(" "),n("p",[t._v("bring the best of open source to you,you team and your company")]),t._v(" "),n("ol",[n("li",[t._v("node_modules 和 lockfiles 再重新install，这样操作是否存在风险")])]),t._v(" "),n("p",[t._v("npm 缓存机制")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[t._v("所有的依赖安装在dependencies中、不区分devDependcies会有问题吗")])]),t._v(" "),n("li",[n("p",[t._v("应用依赖了A和B、A依赖了B B会被重复打包吗")])]),t._v(" "),n("li",[n("p",[t._v("一个项目中有人用npm、有人用yarn、会引发什么问题吗")])]),t._v(" "),n("li",[n("p",[t._v("lockfiles文件提交到仓库？")])])]),t._v(" "),n("h3",{attrs:{id:"npm脚本优点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm脚本优点"}},[t._v("#")]),t._v(" npm脚本优点")]),t._v(" "),n("p",[t._v("项目相关的脚本可以集中在一个地方。")]),t._v(" "),n("p",[t._v("不同项目的脚本命令、只要功能相同，就可以有同样的对外接口。用户不需要怎么测试你的项目，只要运行npm run test就可。")]),t._v(" "),n("p",[t._v("可以用npm提供的很多辅助功能。")]),t._v(" "),n("h3",{attrs:{id:"原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),n("p",[t._v("每当执行npm run，就会自动新建一个Shell，在这个Shell里面执行指定的脚本命令。因此只要是Shell可以运行的命令，就可以写在npm脚本里面")]),t._v(" "),n("p",[t._v("npm run新建的这个Shell、会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。")]),t._v(" "),n("p",[t._v("这意味着，当前目录node_modules/.bin子目录下面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如当前项目依赖")]),t._v(" "),n("p",[t._v("https://blog.csdn.net/u010013405/article/details/116588718")])])}),[],!1,null,null,null);n.default=a.exports}}]);